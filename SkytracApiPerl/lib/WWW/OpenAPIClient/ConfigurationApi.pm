=begin comment

Quicksilver Web API

Further detail about the available features and configuration options can be found in the User Guide.    # Authorization All API calls use bearer authorization except for the following. - POST /api/user/sessions - Uses basic authorization - GET /api/events - Uses query string authorization  # Errors Since the following errors can happen with any API call or with a broad group of API calls, they are documented here rather than for each API call. - 400 (Bad Request). This may occur for any API call, due to the authorization header being malformed. It may also occur due to malformed or incorrect JSON structure of the request body. Other more specific reasons are documented on a per API basis below. - 401 (Unauthenticated) - 403 (Unauthorized). If the user is authenticated as a user with the Standard role, but the API call requires the Admin role. - 500 (Internal Server Error) 

The version of the OpenAPI document: 0.2.0

Generated by: https://openapi-generator.tech

=end comment

=cut

#
# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# Do not edit the class manually.
# Ref: https://openapi-generator.tech
#
package WWW::OpenAPIClient::ConfigurationApi;

require 5.6.0;
use strict;
use warnings;
use utf8;
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::OpenAPIClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::OpenAPIClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::OpenAPIClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# cfg_type_dns_get
#
# Get the DNS settings
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_dns_get' } = {
        summary => 'Get the DNS settings',
        params => $params,
        returns => 'DnsSettingsResponse',
        };
}
# @return DnsSettingsResponse
#
sub cfg_type_dns_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_dns_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/dns';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('DnsSettingsResponse', $response);
    return $_response_object;
}

#
# cfg_type_dns_patch
#
# Set the DNS settings
#
# @param CfgType $type The configuration type (required)
# @param DnsSettingsRequest $dns_settings_request  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'dns_settings_request' => {
        data_type => 'DnsSettingsRequest',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_dns_patch' } = {
        summary => 'Set the DNS settings',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_dns_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_dns_patch");
    }

    # verify the required parameter 'dns_settings_request' is set
    unless (exists $args{'dns_settings_request'}) {
      croak("Missing the required parameter 'dns_settings_request' when calling cfg_type_dns_patch");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/dns';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'dns_settings_request'}) {
        $_body_data = $args{'dns_settings_request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_eth_get
#
# Get the Ethernet settings
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_eth_get' } = {
        summary => 'Get the Ethernet settings',
        params => $params,
        returns => 'EthSettingsResponse',
        };
}
# @return EthSettingsResponse
#
sub cfg_type_eth_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_eth_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/eth';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('EthSettingsResponse', $response);
    return $_response_object;
}

#
# cfg_type_eth_patch
#
# Set the Ethernet settings. Please note that if you change the address at which you are accessing the server you WILL LOSE connection and have to reconnect at the new address. DHCP settings should be updated to ensure that the range falls within the network defined by the address and mask
#
# @param CfgType $type The configuration type (required)
# @param EthSettingsRequest $eth_settings_request  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'eth_settings_request' => {
        data_type => 'EthSettingsRequest',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_eth_patch' } = {
        summary => 'Set the Ethernet settings. Please note that if you change the address at which you are accessing the server you WILL LOSE connection and have to reconnect at the new address. DHCP settings should be updated to ensure that the range falls within the network defined by the address and mask',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_eth_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_eth_patch");
    }

    # verify the required parameter 'eth_settings_request' is set
    unless (exists $args{'eth_settings_request'}) {
      croak("Missing the required parameter 'eth_settings_request' when calling cfg_type_eth_patch");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/eth';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'eth_settings_request'}) {
        $_body_data = $args{'eth_settings_request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_get
#
# Get the complete configuration
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_get' } = {
        summary => 'Get the complete configuration',
        params => $params,
        returns => 'ConfigurationResponse',
        };
}
# @return ConfigurationResponse
#
sub cfg_type_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ConfigurationResponse', $response);
    return $_response_object;
}

#
# cfg_type_gps_dyn_platform_model_get
#
# Get the GPS dynamic platform model setting
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_gps_dyn_platform_model_get' } = {
        summary => 'Get the GPS dynamic platform model setting',
        params => $params,
        returns => 'GpsDynPlatformModel',
        };
}
# @return GpsDynPlatformModel
#
sub cfg_type_gps_dyn_platform_model_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_gps_dyn_platform_model_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/gps/dynPlatformModel';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAllRoles )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('GpsDynPlatformModel', $response);
    return $_response_object;
}

#
# cfg_type_gps_dyn_platform_model_put
#
# Set the GPS dynamic platform model setting
#
# @param CfgType $type The configuration type (required)
# @param string $body  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'body' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_gps_dyn_platform_model_put' } = {
        summary => 'Set the GPS dynamic platform model setting',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_gps_dyn_platform_model_put {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_gps_dyn_platform_model_put");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling cfg_type_gps_dyn_platform_model_put");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/gps/dynPlatformModel';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_gps_keep_on_get
#
# Get the GPS keep on setting. This indicates whether GPS will remain on or turn off and on automatically as needed
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_gps_keep_on_get' } = {
        summary => 'Get the GPS keep on setting. This indicates whether GPS will remain on or turn off and on automatically as needed',
        params => $params,
        returns => 'boolean',
        };
}
# @return boolean
#
sub cfg_type_gps_keep_on_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_gps_keep_on_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/gps/keepOn';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAllRoles )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('boolean', $response);
    return $_response_object;
}

#
# cfg_type_gps_keep_on_put
#
# Set the GPS keep on setting. This indicates whether GPS will remain on or turn off and on automatically as needed
#
# @param CfgType $type The configuration type (required)
# @param boolean $body  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'body' => {
        data_type => 'boolean',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_gps_keep_on_put' } = {
        summary => 'Set the GPS keep on setting. This indicates whether GPS will remain on or turn off and on automatically as needed',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_gps_keep_on_put {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_gps_keep_on_put");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling cfg_type_gps_keep_on_put");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/gps/keepOn';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_gps_sync_time_get
#
# Get the GPS sync time setting.
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_gps_sync_time_get' } = {
        summary => 'Get the GPS sync time setting.',
        params => $params,
        returns => 'boolean',
        };
}
# @return boolean
#
sub cfg_type_gps_sync_time_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_gps_sync_time_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/gps/syncTime';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAllRoles )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('boolean', $response);
    return $_response_object;
}

#
# cfg_type_gps_sync_time_put
#
# Set the GPS sync time setting. If set to true this will synchronize system time with the time received from the GPS fix.
#
# @param CfgType $type The configuration type (required)
# @param boolean $body  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'body' => {
        data_type => 'boolean',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_gps_sync_time_put' } = {
        summary => 'Set the GPS sync time setting. If set to true this will synchronize system time with the time received from the GPS fix.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_gps_sync_time_put {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_gps_sync_time_put");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling cfg_type_gps_sync_time_put");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/gps/syncTime';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_ird_mode_get
#
# Get the Iridium mode
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_ird_mode_get' } = {
        summary => 'Get the Iridium mode',
        params => $params,
        returns => 'IrdMode',
        };
}
# @return IrdMode
#
sub cfg_type_ird_mode_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_ird_mode_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/ird/mode';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAllRoles )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('IrdMode', $response);
    return $_response_object;
}

#
# cfg_type_ird_mode_put
#
# Set the Iridium mode. Please make sure device's system time is synced before turning on data mode.
#
# @param CfgType $type The configuration type (required)
# @param string $body  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'body' => {
        data_type => 'string',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_ird_mode_put' } = {
        summary => 'Set the Iridium mode. Please make sure device&#39;s system time is synced before turning on data mode.',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_ird_mode_put {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_ird_mode_put");
    }

    # verify the required parameter 'body' is set
    unless (exists $args{'body'}) {
      croak("Missing the required parameter 'body' when calling cfg_type_ird_mode_put");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/ird/mode';

    my $_method = 'PUT';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'body'}) {
        $_body_data = $args{'body'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_outgoing_firewall_rules_get
#
# Get the outgoing firewall rules
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_outgoing_firewall_rules_get' } = {
        summary => 'Get the outgoing firewall rules',
        params => $params,
        returns => 'ARRAY[OutgoingFirewallRule]',
        };
}
# @return ARRAY[OutgoingFirewallRule]
#
sub cfg_type_outgoing_firewall_rules_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_outgoing_firewall_rules_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/outgoingFirewall/rules';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAllRoles )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[OutgoingFirewallRule]', $response);
    return $_response_object;
}

#
# cfg_type_outgoing_firewall_rules_name_delete
#
# Remove a rule from the outgoing firewall
#
# @param CfgType $type The configuration type (required)
# @param string $name Name of the rule to remove (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'Name of the rule to remove',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_outgoing_firewall_rules_name_delete' } = {
        summary => 'Remove a rule from the outgoing firewall',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_outgoing_firewall_rules_name_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_outgoing_firewall_rules_name_delete");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling cfg_type_outgoing_firewall_rules_name_delete");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/outgoingFirewall/rules/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_outgoing_firewall_rules_name_patch
#
# Update an outgoing firewall rule
#
# @param CfgType $type The configuration type (required)
# @param string $name Name of the rule to update (required)
# @param PatchOutgoingFirewallRule $patch_outgoing_firewall_rule  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'Name of the rule to update',
        required => '1',
    },
    'patch_outgoing_firewall_rule' => {
        data_type => 'PatchOutgoingFirewallRule',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_outgoing_firewall_rules_name_patch' } = {
        summary => 'Update an outgoing firewall rule',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_outgoing_firewall_rules_name_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_outgoing_firewall_rules_name_patch");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling cfg_type_outgoing_firewall_rules_name_patch");
    }

    # verify the required parameter 'patch_outgoing_firewall_rule' is set
    unless (exists $args{'patch_outgoing_firewall_rule'}) {
      croak("Missing the required parameter 'patch_outgoing_firewall_rule' when calling cfg_type_outgoing_firewall_rules_name_patch");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/outgoingFirewall/rules/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'patch_outgoing_firewall_rule'}) {
        $_body_data = $args{'patch_outgoing_firewall_rule'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_outgoing_firewall_rules_post
#
# Inserts a rule into the outgoing firewall
#
# @param CfgType $type The configuration type (required)
# @param OutgoingFirewallRule $outgoing_firewall_rule  (required)
# @param string $before The name of the rule to insert the new rule before. If omitted, the rule is appended to the end of the list. (optional)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'outgoing_firewall_rule' => {
        data_type => 'OutgoingFirewallRule',
        description => '',
        required => '1',
    },
    'before' => {
        data_type => 'string',
        description => 'The name of the rule to insert the new rule before. If omitted, the rule is appended to the end of the list.',
        required => '0',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_outgoing_firewall_rules_post' } = {
        summary => 'Inserts a rule into the outgoing firewall',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_outgoing_firewall_rules_post {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_outgoing_firewall_rules_post");
    }

    # verify the required parameter 'outgoing_firewall_rule' is set
    unless (exists $args{'outgoing_firewall_rule'}) {
      croak("Missing the required parameter 'outgoing_firewall_rule' when calling cfg_type_outgoing_firewall_rules_post");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/outgoingFirewall/rules';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # query params
    if ( exists $args{'before'}) {
        $query_params->{'before'} = $self->{api_client}->to_query_value($args{'before'});
    }

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'outgoing_firewall_rule'}) {
        $_body_data = $args{'outgoing_firewall_rule'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_port_fwd_entries_get
#
# Get the port forwarding entries
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_port_fwd_entries_get' } = {
        summary => 'Get the port forwarding entries',
        params => $params,
        returns => 'ARRAY[PortFwdEntry]',
        };
}
# @return ARRAY[PortFwdEntry]
#
sub cfg_type_port_fwd_entries_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_port_fwd_entries_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/portFwd/entries';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[PortFwdEntry]', $response);
    return $_response_object;
}

#
# cfg_type_port_fwd_entries_name_delete
#
# Remove a port forwarding entry
#
# @param CfgType $type The configuration type (required)
# @param string $name Name of port forwarding entry (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'Name of port forwarding entry',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_port_fwd_entries_name_delete' } = {
        summary => 'Remove a port forwarding entry',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_port_fwd_entries_name_delete {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_port_fwd_entries_name_delete");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling cfg_type_port_fwd_entries_name_delete");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/portFwd/entries/{name}';

    my $_method = 'DELETE';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_port_fwd_entries_name_patch
#
# Update a port forwarding entry
#
# @param CfgType $type The configuration type (required)
# @param string $name Name of port forwarding entry to update (required)
# @param PatchPortFwdEntry $patch_port_fwd_entry  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'name' => {
        data_type => 'string',
        description => 'Name of port forwarding entry to update',
        required => '1',
    },
    'patch_port_fwd_entry' => {
        data_type => 'PatchPortFwdEntry',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_port_fwd_entries_name_patch' } = {
        summary => 'Update a port forwarding entry',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_port_fwd_entries_name_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_port_fwd_entries_name_patch");
    }

    # verify the required parameter 'name' is set
    unless (exists $args{'name'}) {
      croak("Missing the required parameter 'name' when calling cfg_type_port_fwd_entries_name_patch");
    }

    # verify the required parameter 'patch_port_fwd_entry' is set
    unless (exists $args{'patch_port_fwd_entry'}) {
      croak("Missing the required parameter 'patch_port_fwd_entry' when calling cfg_type_port_fwd_entries_name_patch");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/portFwd/entries/{name}';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    # path params
    if ( exists $args{'name'}) {
        my $_base_variable = "{" . "name" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'name'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'patch_port_fwd_entry'}) {
        $_body_data = $args{'patch_port_fwd_entry'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_port_fwd_entries_post
#
# Add a port forwarding entry
#
# @param CfgType $type The configuration type (required)
# @param PortFwdEntry $port_fwd_entry  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'port_fwd_entry' => {
        data_type => 'PortFwdEntry',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_port_fwd_entries_post' } = {
        summary => 'Add a port forwarding entry',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_port_fwd_entries_post {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_port_fwd_entries_post");
    }

    # verify the required parameter 'port_fwd_entry' is set
    unless (exists $args{'port_fwd_entry'}) {
      croak("Missing the required parameter 'port_fwd_entry' when calling cfg_type_port_fwd_entries_post");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/portFwd/entries';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'port_fwd_entry'}) {
        $_body_data = $args{'port_fwd_entry'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

#
# cfg_type_wifi_enabled_get
#
# Get the Wi-Fi enabled configuration
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_wifi_enabled_get' } = {
        summary => 'Get the Wi-Fi enabled configuration',
        params => $params,
        returns => 'boolean',
        };
}
# @return boolean
#
sub cfg_type_wifi_enabled_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_wifi_enabled_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/wifi/enabled';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAllRoles )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('boolean', $response);
    return $_response_object;
}

#
# cfg_type_wifi_get
#
# Get the Wi-Fi configuration
#
# @param CfgType $type The configuration type (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_wifi_get' } = {
        summary => 'Get the Wi-Fi configuration',
        params => $params,
        returns => 'WiFiSettingsResponse',
        };
}
# @return WiFiSettingsResponse
#
sub cfg_type_wifi_get {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_wifi_get");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/wifi';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type();

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('WiFiSettingsResponse', $response);
    return $_response_object;
}

#
# cfg_type_wifi_patch
#
# Set the Wi-Fi configuration
#
# @param CfgType $type The configuration type (required)
# @param WiFiSettingsRequest $wi_fi_settings_request  (required)
{
    my $params = {
    'type' => {
        data_type => 'CfgType',
        description => 'The configuration type',
        required => '1',
    },
    'wi_fi_settings_request' => {
        data_type => 'WiFiSettingsRequest',
        description => '',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'cfg_type_wifi_patch' } = {
        summary => 'Set the Wi-Fi configuration',
        params => $params,
        returns => undef,
        };
}
# @return void
#
sub cfg_type_wifi_patch {
    my ($self, %args) = @_;

    # verify the required parameter 'type' is set
    unless (exists $args{'type'}) {
      croak("Missing the required parameter 'type' when calling cfg_type_wifi_patch");
    }

    # verify the required parameter 'wi_fi_settings_request' is set
    unless (exists $args{'wi_fi_settings_request'}) {
      croak("Missing the required parameter 'wi_fi_settings_request' when calling cfg_type_wifi_patch");
    }

    # parse inputs
    my $_resource_path = '/cfg/{type}/wifi';

    my $_method = 'PATCH';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept();
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    # path params
    if ( exists $args{'type'}) {
        my $_base_variable = "{" . "type" . "}";
        my $_base_value = $self->{api_client}->to_path_value($args{'type'});
        $_resource_path =~ s/$_base_variable/$_base_value/g;
    }

    my $_body_data;
    # body params
    if ( exists $args{'wi_fi_settings_request'}) {
        $_body_data = $args{'wi_fi_settings_request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw(BearerAuthAdminOnly )];

    # make the API Call
    $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    return;
}

1;
